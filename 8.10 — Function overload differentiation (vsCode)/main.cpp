#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int add(int x, int y, int z)
{
    return x + y + z;
}

int main()
{
    std::cout << std::endl;
    /////////////////////////////////////////////////////////////////////////////
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    std::cout << "Function overload differentiation" << '\n';
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    /////////////////////////////////////////////////////////////////////////////
    /*
    Overloaded functions that are not properly differentiated will cause the compiler to 
    issue a compile error.
    */

    std::cout << std::endl;
    /////////////////////////////////////////////////////////////////////////////
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    std::cout << "How overloaded functions are differentiated" << '\n';
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    /////////////////////////////////////////////////////////////////////////////
    /*
    The easiest way to differentiate an overload function is to ensure each overloaded function 
    has a different set (number and/or type) of parameters.
    */

    std::cout << std::endl;
    /////////////////////////////////////////////////////////////////////////////
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    std::cout << "Overloading based on number of parameters" << '\n';
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    /////////////////////////////////////////////////////////////////////////////
    /*
    An overloaded function is differentiated so long as each overloaded function has a different 
    number of parameters. For example:
    */
    add(1, 2);
    add(1, 2, 3);
    /*
    The compiler can easily tell that a function call with two integer parameters should go 
    to add(int, int) and a function call with three integer parameters should go to add(int, int, int).
    */

    std::cout << std::endl;
    /////////////////////////////////////////////////////////////////////////////
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    std::cout << "Overloading based on type of parameters" << '\n';
    std::cout << "/////////////////////////////////////////////////////" << '\n';
    /////////////////////////////////////////////////////////////////////////////
    /*
    Is not allowed use typedef or an alliases for overloading parameters function.
    For parameters passed by value, the const qualifier is also not considered
    */

    std::cout << std::endl;
    ///////////////////////////////////////////////////////////////////////////////////////////
    std::cout << "///////////////////////////////////////////////////////////////////" << '\n';
    std::cout << "The return type of a function is not considered for differentiation" << '\n';
    std::cout << "///////////////////////////////////////////////////////////////////" << '\n';
    ///////////////////////////////////////////////////////////////////////////////////////////

    std::cout << std::endl;
    ///////////////////////////////////////////////////////////////////////////////////////////
    std::cout << "///////////////////////////////////////////////////////////////////" << '\n';
    std::cout << "Name mangling" << '\n';
    std::cout << "///////////////////////////////////////////////////////////////////" << '\n';
    ///////////////////////////////////////////////////////////////////////////////////////////
    
    
    


    return 0;
}